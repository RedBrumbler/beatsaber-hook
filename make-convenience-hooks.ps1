# This script reads the hooking.hpp file, finds all MAKE_HOOK definitions, and generates corresponding MAKE_HOOK_AUTO definitions.
# The output is saved to convenience-hooks.hpp.

# Define the input and output file paths
param (
    [string]$inputFilePath = "./shared/utils/hooking.hpp",
    [string]$outputFilePath = "./shared/utils/convenience-hooks.hpp"
)

# Check if the input file exists
if (-Not (Test-Path -Path $inputFilePath -PathType Leaf)) {
    Write-Error "Input file '$inputFilePath' does not exist or is not a file."
    exit 1
}

# Define the regex pattern to match MAKE_HOOK definitions
$pattern = (
    '(?ms)'                         + # Multiline and single-line mode
    '(?:^[ \t]*//[^\r\n]*\r?\n)+?'  + # Match one or more lines of comments
    '^\s*#define\s+'                + # Match the '#define' keyword with optional leading whitespace
    '(MAKE_HOOK(?:_\w+)?)'          + # Capture the macro name (e.g., MAKE_HOOK, MAKE_HOOK_SOMETHING)
    '\(([^)]*)\)'                   + # Capture the macro parameters inside parentheses
    '((?:[^\n]*\\\r?\n)+(?:[^\n]+)?)' # Capture the macro body spanning multiple lines
)

# Read the file content
$fileContent = Get-Content -Path $inputFilePath -Raw

# Match the pattern and extract to an array
$matches = [regex]::Matches($fileContent, $pattern)

# Create an array to store the results
$resultArray = @()

# Iterate over the matches and add them to the result array
foreach ($match in $matches) {
    $resultArray += $match.Value
}

# Function to replace regex in a copy of the result values
function ReplaceMakeWithAuto {
    param (
        [array]$inputArray,
        [string]$modifier,
        [string]$macroPrefix = "INSTALL_HOOK_DEFERRED",
        [string]$macroSuffix = "",
        [string]$macroKeyword = "AUTO"
    )

    $outputArray = @()
    foreach ($item in $inputArray) {
        # This regex pattern matches lines that define a MAKE_HOOK macro and captures the parts to be replaced.
        # ^(\s*#define\s+MAKE_): Matches the start of the line, optional whitespace, '#define MAKE_' and captures it.
        # (HOOK): Matches 'HOOK' and captures it.
        # ([^(]+)?: Matches any characters except '(', capturing them if present.
        $lines = ([regex]::Replace($item, "(?ms)^(\s*#define\s+MAKE_)(HOOK)([^(]+)?", "`$1${macroKeyword}${modifier}_`$2`$3")) -split "`n"

        # Insert the macro installation line before the last line
        $lines[-1] = "$macroPrefix$modifier$macroSuffix(name_); \`n" + $lines[-1]

        # Trim trailing spaces from all lines
        $lines = $lines | ForEach-Object { $_.TrimEnd() }

        # Join the lines back into a single string
        $newItem = $lines -join "`n"

        # Add the modified item to the output array
        $outputArray += $newItem.Trim()
    }
    return $outputArray
}

# Call the function and print the modified array
$modifiedArray += ReplaceMakeWithAuto -inputArray $resultArray -macroPrefix "MAKE_DEFERRED" -macroSuffix "_HOOK_INSTALL_WITH_AUTOLOGGER" -macroKeyword "DEFERRED"
$modifiedArray += ReplaceMakeWithAuto -inputArray $resultArray -modifier "_ORIG" -macroPrefix "MAKE_DEFERRED" -macroSuffix "_HOOK_INSTALL_WITH_AUTOLOGGER" -macroKeyword "DEFERRED"
$modifiedArray += ReplaceMakeWithAuto -inputArray $resultArray -macroPrefix "INSTALL" -macroSuffix "_HOOK_ON_DLOPEN_WITH_AUTOLOGGER" -macroKeyword "DLOPEN"
$modifiedArray += ReplaceMakeWithAuto -inputArray $resultArray -modifier "_ORIG" -macroPrefix "INSTALL" -macroSuffix "_HOOK_ON_DLOPEN_WITH_AUTOLOGGER" -macroKeyword "DLOPEN"

# Write the output to the specified file
$outputContent = @"
/// @file $([System.IO.Path]::GetFileName($outputFile))
/// @brief Contains convenience macros to create hooks and register for user-initiated
/// installation at a later time with the INSTALL_DEFERRED_HOOKS macro or automatically
/// installed on dlopen.
///
/// IMPORTANT: This file is automatically generated.
/// Do not edit this file directly. Any changes made to this file will be overwritten.
/// Please modify the make-convenience-hooks.ps1 script that generates this file instead.

#pragma once
#include "hooking.hpp"

$($modifiedArray -join "`n`n")
"@ -replace "`r", ""

if ($IsWindows) {
    Set-Content -Path $outputFilePath -Value ($outputContent -replace "`n", "`r`n")
} else {
    Set-Content -Path $outputFilePath -Value $outputContent
}
